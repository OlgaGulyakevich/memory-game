<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>–ò–≥—Ä–∞ –ú–µ–º–æ—Ä–∏. –ò–≥—Ä–∞ –¥–ª—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ –ø–∞–º—è—Ç–∏ –Ω–∞ —Ä–∞–∑–Ω—ã—Ö –Ω–∞–±–æ—Ä–∞—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π</title>
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="stylesheet" href="css/style.css">
  <script src="vendor/react.development.js"></script> 
  <script src="vendor/react-dom.development.js"></script>
  <script src="vendor/babel.min.js"></script>
  <script src="vendor/get-declension.min.umd.js"></script>
  <script src="js/data.js"></script>
  <script src="js/setting.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    
    // –ü—Ä–æ—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Å–∫–ª–æ–Ω–µ–Ω–∏—è —á–∏—Å–ª–∏—Ç–µ–ª—å–Ω—ã—Ö
    const getDeclension = (count, words) => {
      const cases = [2, 0, 1, 1, 1, 2];
      return words[(count % 100 > 4 && count % 100 < 20) ? 2 : cases[Math.min(count % 10, 5)]];
    };
    
    root.render(<App />);

    // üéÆ –õ–æ–≥–∏–∫–∞ –∏–≥—Ä—ã –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º —Ö—É–∫–µ 
    const useGame = (images) => {
      const [finishedItems, setFinishedItems] = React.useState([]);
      const [stepsCount, setStepsCount] = React.useState(0);
      const [errors, setErrors] = React.useState(0);

      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä—ã –∫–∞—Ä—Ç–æ—á–µ–∫ 
      const checkItems = (firstItem, secondItem) => {
        const firstImage = images.find(({id}) => id === firstItem);
        const secondImage = images.find(({id}) => id === secondItem);
        
        if (firstImage.url === secondImage.url) {
          // –ü–∞—Ä–∞ —Å–æ–≤–ø–∞–ª–∞ - –¥–æ–±–∞–≤–ª—è–µ–º –≤ –æ—Ç–≥–∞–¥–∞–Ω–Ω—ã–µ
          setFinishedItems((items) => [...items, firstItem, secondItem]);
        } else {
          // –ü–∞—Ä–∞ –Ω–µ —Å–æ–≤–ø–∞–ª–∞ - —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –æ—à–∏–±–∫–∏
          setErrors((e) => e + 1);
        }
        // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ —à–∞–≥–æ–≤
        setStepsCount((i) => i + 1);
      };

      // –°–±—Ä–æ—Å –∏–≥—Ä—ã
      const handleReset = () => {
        setFinishedItems([]);
        setStepsCount(0);
        setErrors(0);
      };

      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–±–µ–¥—ã
      const isWin = finishedItems.length > 0 && finishedItems.length === images.length;
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Ä–∞–∂–µ–Ω–∏—è
      const isGameOver = errors >= GAME_SETTINGS.LIVES_COUNT;

      return {
        finishedItems,
        handleReset,
        stepsCount,
        errors,
        checkItems,
        isWin,
        isGameOver
      };
    };

    function App() {
      // –≠–∫—Ä–∞–Ω—ã –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
      const [currentScreen, setCurrentScreen] = React.useState(SCREENS.START);
      const [currentResult, setCurrentResult] = React.useState(null);
      const [allResults, setAllResults] = React.useState([]);
      const [selectedTheme, setSelectedTheme] = React.useState('cats');
      const [gameImages, setGameImages] = React.useState([]);
       

      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∏–≥—Ä—ã
      const handleGameFinish = React.useCallback((gameData) => {
        const newResult = {
          name: '–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç',
          stepsCount: gameData.moves,
          errors: gameData.errors,
          timestamp: new Date().toISOString(),
          isCurrent: true
        };
        setCurrentResult(newResult);
        
        // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º
        const updatedResults = [...allResults, newResult];
        setAllResults(updatedResults);
        
        // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ —ç–∫—Ä–∞–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        setCurrentScreen(SCREENS.RESULTS);
        window.history.pushState({ screen: SCREENS.RESULTS }, '–†–µ–∑—É–ª—å—Ç–∞—Ç—ã', '/results');
      }, [allResults]);

      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ —Ç–µ–º—ã –∏ –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã
      const handleThemeSelect = React.useCallback((theme) => {
        setSelectedTheme(theme);
        setGameImages(getImages(theme));
        setCurrentScreen(SCREENS.GAME);
        window.history.pushState({ screen: SCREENS.GAME }, '–ò–≥—Ä–∞', '/game');
      }, []);

      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–æ–≤–æ–π –∏–≥—Ä—ã
      const handleNewGame = () => {
        setCurrentScreen(SCREENS.START);
        setCurrentResult(null);
        window.history.pushState({ screen: SCREENS.START }, '–°—Ç–∞—Ä—Ç', '/start');
      };

      // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–∏ –º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
      React.useEffect(() => {
        fetch('results.json')
          .then(response => response.json())
          .then(data => setAllResults(data))
          .catch(()=> setAllResults(results)); // Fallback –Ω–∞ —Å—Ç–∞—Ç–∏—á–Ω—ã–π –º–∞—Å—Å–∏–≤
      }, []);

      // –°–ª—É—à–∞—Ç–µ–ª—å –¥–ª—è back/forward
      React.useEffect(() => {
        const handlePopState = (event) => {
          if (event.state && event.state.screen) {
            setCurrentScreen(event.state.screen);
          } else {
            setCurrentScreen(SCREENS.START);  // Fallback –Ω–∞ —Å—Ç–∞—Ä—Ç
          }
        };
        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
      }, []);

      // –†–µ–Ω–¥–µ—Ä–∏–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —ç–∫—Ä–∞–Ω
      if (currentScreen === SCREENS.START) {
        return (
          <StartScreen onThemeSelect={handleThemeSelect} />
        );
      }

      if (currentScreen === SCREENS.RESULTS) {
        return (
          <ResultScreen 
            currentResult={currentResult}
            allResults={allResults}
            onNewGame={handleNewGame}
            selectedTheme={selectedTheme}
          />
        );
      }

      // –ù–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–≥—Ä—É –±–µ–∑ –∫–∞—Ä—Ç–æ—á–µ–∫
      if (gameImages.length === 0) {
        return <StartScreen onThemeSelect={handleThemeSelect} />;
      }

      return (
        <GameScreen 
          images={gameImages}
          selectedTheme={selectedTheme}
          onGameFinish={handleGameFinish}
          onShowResults={() => setCurrentScreen(SCREENS.RESULTS)}
          onNewGame={handleNewGame}
        />
      );
    }

    // –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –∏–≥—Ä–æ–≤–æ–≥–æ —ç–∫—Ä–∞–Ω–∞
    function GameScreen({ images, selectedTheme, onGameFinish, onShowResults, onNewGame }) {
      const {
        finishedItems,
        handleReset,
        stepsCount,
        errors,
        checkItems,
        isWin,
        isGameOver
      } = useGame(images);
      // –£–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–∫–∞–∑–æ–º –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ –ø–æ–±–µ–¥—ã
      const [showVictoryModal, setShowVictoryModal] = React.useState(false);
      React.useEffect(() => {
        if (isWin) {
          const timerId = setTimeout(() => setShowVictoryModal(true), 100);
          return () => clearTimeout(timerId);
        }
      }, [isWin]);

      // –í—ã—á–∏—Å–ª—è–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
      const totalPairs = images.length / 2;
      const matchedPairs = finishedItems.length / 2;
      const remainingLives = GAME_SETTINGS.LIVES_COUNT - errors;

      return (
        <section className="game container">
          <GameHeader 
            moves={stepsCount}
            progress={(matchedPairs / totalPairs) * 100}
            remainingLives={remainingLives}
            matchedPairs={matchedPairs}
            totalPairs={totalPairs}
          />
          
          <GameBoard
            images={images}
            selectedTheme={selectedTheme}
            finishedItems={finishedItems}
            checkItems={checkItems}
            isGameOver={isGameOver}
          />

          {/* –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –ø–æ—Ä–∞–∂–µ–Ω–∏—è */}
          {isGameOver && !isWin && (
            <GameModal 
              isWin={false}
              moves={stepsCount}
              matchedPairs={matchedPairs}
              onRestart={() => {
                setShowVictoryModal(false);
                handleReset();
              }}
              onNewGame={onNewGame}
              onShowResults={()=> {
                onGameFinish();
              }}
            />
          )}

          {/* –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –ø–æ–±–µ–¥—ã */}
          {showVictoryModal && isWin && (
            <GameModal 
              isWin={true}
              moves={stepsCount}
              matchedPairs={matchedPairs}
              onRestart={() => {
                setShowVictoryModal(false);
                handleReset();
              }}
              onNewGame={onNewGame}
              onShowResults={()=> {
                onGameFinish({
                  moves: stepsCount, 
                  errors: errors
                });
              }}
            />
          )}
        </section>
      );
    }

    // –ö–æ–º–ø–æ–Ω–µ–Ω—Ç —à–∞–ø–∫–∏ –∏–≥—Ä—ã
    function GameHeader({ moves, progress, remainingLives, matchedPairs, totalPairs }) {
      return (
        <>
          <div className="progress-wrapper">
            <div className="progress" style={{ width: `${progress}%` }}></div>
          </div>
          <p className="progress-description">
            –û—Ç–∫—Ä—ã—Ç–æ <span>{matchedPairs}</span> / <span>{totalPairs}</span>
          </p>
          <div className="steps">–®–∞–≥ {moves}</div>
        </>
      );
    }

    // –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è 
    function GameBoard({images = [], selectedTheme = 'cats', finishedItems, checkItems, isGameOver}) {
      const [visibleItems, setVisibleItems] = React.useState([]);

      const handleCardClick = React.useCallback((id) => {
        // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–ª–∏–∫–∏ –µ—Å–ª–∏ –∏–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞, –∫–∞—Ä—Ç–æ—á–∫–∞ –æ—Ç–≥–∞–¥–∞–Ω–∞ –∏–ª–∏ —É–∂–µ –≤–∏–¥–∏–º–∞
        if (isGameOver || finishedItems.includes(id) || visibleItems.includes(id)) {
          return;
        }

        // –õ–æ–≥–∏–∫–∞ –∫–ª–∏–∫–∞ –ø–æ –∫–∞—Ä—Ç–æ—á–∫–∞–º
        switch (visibleItems.length) {
          case 0:
            // –ü–µ—Ä–≤–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞ - –ø—Ä–æ—Å—Ç–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º
            setVisibleItems([id]);
            break;
          case 1:
            // –í—Ç–æ—Ä–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ä—É
            setVisibleItems((items) => [...items, id]);
            checkItems(visibleItems[0], id);
            
            // –°—Ç–∞–≤–∏–º —Ç–∞–π–º–µ—Ä –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –≤–∏–¥–∏–º—ã—Ö –∫–∞—Ä—Ç–æ—á–µ–∫
            setTimeout(() => {
              setVisibleItems([]);
            }, GAME_SETTINGS.FLIP_DELAY);
            break;
          default:
            // –¢—Ä–µ—Ç—å—è –∫–∞—Ä—Ç–æ—á–∫–∞ –∏ –±–æ–ª—å—à–µ - –ø—Ä–æ—Å—Ç–æ –æ—á–∏—â–∞–µ–º –≤–∏–¥–∏–º—ã–µ
            setVisibleItems([]);
        }
      }, [isGameOver, finishedItems, visibleItems, checkItems]);

      return (
        <ul className={`cards cards-theme-${selectedTheme}`}>
          {images.map((item) => (
            <Card
              key={item.id}
              item={item}
              isVisible={visibleItems.includes(item.id)}
              isFinished={finishedItems.includes(item.id)}
              onCardClick={handleCardClick}
            />
          ))}
        </ul>
      );
    }

    // –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –∫–∞—Ä—Ç–æ—á–∫–∏
    function Card({item, isVisible, isFinished, onCardClick}) {
      const {id, url, description} = item;
      const className = `${isVisible ? 'card-show' : ''} ${isFinished ? 'card-finished' : ''}`;

      const handleClick = () => onCardClick(id);
      
      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
      const handleKeyDown = (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          onCardClick(id);
        }
      };

      return (
        <li 
          onClick={handleClick}
          onKeyDown={handleKeyDown} 
          className={`card ${className}`} 
          role="button" 
          tabIndex={isFinished ? -1 : 0} 
          aria-label={isFinished ? '–°–æ–±—Ä–∞–Ω–Ω–∞—è –ø–∞—Ä–∞' : '–ó–∞–∫—Ä—ã—Ç–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞, –Ω–∞–∂–º–∏—Ç–µ Enter –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è'}
        >
          <img width="204" height="144" src={url} alt={description || '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫–∞—Ä—Ç–æ—á–∫–∏'} />
        </li>
      );
    }

    // –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞
    function GameModal({ isWin, moves, matchedPairs, onRestart, onNewGame, onShowResults }) {
      return (
        <div className="modal">
          <div className="modal-box">
            <h3 className="modal-caption">
              {isWin ? '–ü–æ–±–µ–¥–∞!' : '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞'}
            </h3>
            <p className="modal-description">
              {isWin 
                ? '–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ —É–∑–Ω–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —ç—Ç–æ–π –ø–∞—Ä—Ç–∏–∏'
                : `–í—ã —Å–æ–±—Ä–∞–ª–∏ ${matchedPairs} ${getDeclension(matchedPairs, ['–ø–∞—Ä—É', '–ø–∞—Ä—ã', '–ø–∞—Ä'])}`
              }
            </p>
            <div className="modal-buttons">
              {isWin ? (
                <button 
                  className="button modal-button" 
                  type="button" 
                  onClick={onShowResults}
                >
                  –ü–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
                </button>
              ) : (
                <>
                  <button className="button modal-button" type="button" 
                  onClick={onNewGame}>
                    –ù–æ–≤–∞—è –∏–≥—Ä–∞
                  </button>
                </>
              )}
            </div>
          </div>
        </div>
      );
    }

    // –ö–æ–º–ø–æ–Ω–µ–Ω—Ç —ç–∫—Ä–∞–Ω–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    function ResultScreen({ currentResult, allResults, onNewGame, selectedTheme }) {
      // –§–∏–ª—å—Ç—Ä—É–µ–º –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ç–µ–º–µ
      const combinedResults = React.useMemo(() => {
        const filteredByTheme = allResults.filter(result => result.theme === selectedTheme);
        const results = [...filteredByTheme];
        
        if (currentResult) {
          // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç (—Å —Ç–µ–º–æ–π)
          currentResult.theme = selectedTheme;
          results.push(currentResult);
        }
        
        // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é —à–∞–≥–æ–≤
        return results.sort((a, b) => a.stepsCount - b.stepsCount);
      }, [allResults, currentResult, selectedTheme]);

      return (
        <section className="result container">
          <h2>–õ—É—á—à–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è —Ç–µ–º—ã "{themes[selectedTheme].name}":</h2>
          
          {currentResult && (
            <p>
              –í—ã –∑–∞–≤–µ—Ä—à–∏–ª–∏ –∏–≥—Ä—É –∑–∞ <b>{currentResult.stepsCount} {getDeclension(currentResult.stepsCount, ['—à–∞–≥', '—à–∞–≥–∞', '—à–∞–≥–æ–≤'])}</b>, —Ç–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!
            </p>
          )}
          
          {combinedResults.length > 0 ? (
            <table className="result-table">
              <thead>
                <tr className="result-table-row">
                  <th>–ú–µ—Å—Ç–æ</th>
                  <th>–ò–º—è</th>
                  <th>–®–∞–≥–∏</th>
                </tr>
              </thead>
              <tbody>
                {combinedResults.map((result, index) => (
                  <tr 
                    key={`${result.name}-${result.stepsCount}-${index}`}
                    className={`result-table-row ${result.isCurrent ? 'active' : ''}`}
                  >
                    <td>{index + 1}</td>
                    <td>{result.name}</td>
                    <td>{result.stepsCount}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          ) : (
            <p>–ü–æ–∫–∞ –Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è —ç—Ç–æ–π —Ç–µ–º—ã. –°—ã–≥—Ä–∞–π—Ç–µ, —á—Ç–æ–±—ã —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ä–µ–∫–æ—Ä–¥!</p>
          )}
          
          <p>–•–æ—Ç–∏—Ç–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â—ë —Ä–∞–∑?</p>
          
          <div style={{ display: 'flex', justifyContent: 'center', marginTop: '24px' }}>
            <button 
              className="button result-button" 
              type="button"
              onClick={onNewGame}
            >
              –ù–æ–≤–∞—è –∏–≥—Ä–∞
            </button>
          </div>
        </section>
      );
    }

    // –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ —ç–∫—Ä–∞–Ω–∞
    function StartScreen({ onThemeSelect }) {
      return (
        <section className="rules container">
          <h2>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!</h2>
          <p>Memory ‚Äî –∏–≥—Ä–∞ –¥–ª—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ –≤–∏–∑—É–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏</p>
          <div className="rules-panel">
            <h3>–ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã</h3>
            <ul className="rules-list">
              <li>–í –Ω–∞–±–æ—Ä–µ –µ—Å—Ç—å –º–Ω–æ–∂–µ—Å—Ç–≤–æ –∫–∞—Ä—Ç–æ—á–µ–∫ ‚Äì –ø–æ –¥–≤–µ —à—Ç—É–∫–∏ —Å –æ–¥–Ω–∏–º –∏ —Ç–µ–º –∂–µ —Ä–∏—Å—É–Ω–∫–æ–º.</li>
              <li>–ù—É–∂–Ω–æ —Ä–∞–∑–ª–æ–∂–∏—Ç—å –∫–∞—Ä—Ç–æ—á–∫–∏ ¬´—Ä—É–±–∞—à–∫–æ–π¬ª –≤–≤–µ—Ä—Ö –Ω–∞ —Å—Ç–æ–ª–µ, –∞ –∑–∞—Ç–µ–º –ø–µ—Ä–µ–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å –ø–æ –¥–≤–µ.</li>
              <li>–ï—Å–ª–∏ –æ–Ω–∏ —Å–æ–≤–ø–∞–¥–∞—é—Ç ‚Äì –∏–≥—Ä–æ–∫ –∑–∞–±–∏—Ä–∞–µ—Ç –∏—Ö –∏ –ø–æ–ª—É—á–∞–µ—Ç –µ—â—ë –æ–¥–∏–Ω —Ö–æ–¥.</li>
            </ul>
          </div>
           {/* –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ç–µ–º */}
      <div className="theme-buttons">
        {Object.keys(themes).map((themeKey) => (
          <button 
            key={themeKey}
            className={`ico-button ico-button-${themeKey}`}
            type="button"
            onClick={() => onThemeSelect(themeKey)}
            aria-label={`–í—ã–±—Ä–∞—Ç—å —Ç–µ–º—É ${themes[themeKey].name}`}
          >
            {themes[themeKey].name}
          </button>
        ))}
      </div>
        </section>
      );
    }

  </script>
</body>
</html>