<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"> 
  <title>Игра Мемори. Игра для тренировки памяти на разных наборах изображений</title>
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="stylesheet" href="css/style.css">
  <script src="vendor/react.development.js"></script> 
  <script src="vendor/react-dom.development.js"></script>
  <script src="vendor/babel.min.js"></script>
  <script src="vendor/get-declension.min.umd.js"></script>
  <script src="js/data.js"></script>
  <script src="js/setting.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    
    // Простая функция склонения числительных
    const getDeclension = (count, words) => {
      const cases = [2, 0, 1, 1, 1, 2];
      return words[(count % 100 > 4 && count % 100 < 20) ? 2 : cases[Math.min(count % 10, 5)]];
    };
    
    root.render(<App />);

    function App() {
      // Экраны приложения
      const [currentScreen, setCurrentScreen] = React.useState(SCREENS.START);
      const [currentResult, setCurrentResult] = React.useState(null);
      const [allResults, setAllResults] = React.useState([]);
      const [selectedTheme, setSelectedTheme] = React.useState('cats');
      const [gameImages, setGameImages] = React.useState([]);
       

      // Обработчик завершения игры
      const handleGameFinish = React.useCallback((gameData) => {
        const newResult = {
          name: 'Ваш результат',
          stepsCount: gameData.moves,
          errors: gameData.errors,
          timestamp: new Date().toISOString(),
          isCurrent: true
        };
        setCurrentResult(newResult);
        
        // Добавляем новый результат к существующим
        const updatedResults = [...allResults, newResult];
        setAllResults(updatedResults);
        
        // Переходим на экран результатов
        setCurrentScreen(SCREENS.RESULTS);
        window.history.pushState({ screen: SCREENS.RESULTS }, 'Результаты', '/results');
      }, [allResults]);

      // Обработчик выбора темы и начала игры
      const handleThemeSelect = React.useCallback((theme) => {
        setSelectedTheme(theme);
        setGameImages(getImages(theme));
        setCurrentScreen(SCREENS.GAME);
        window.history.pushState({ screen: SCREENS.GAME }, 'Игра', '/game');
      }, []);

      // Обработчик новой игры
      const handleNewGame = () => {
        setCurrentScreen(SCREENS.START);
        setCurrentResult(null);
        window.history.pushState({ screen: SCREENS.START }, 'Старт', '/start');
      };

      // Загружаем результаты при монтировании
      React.useEffect(() => {
        fetch('results.json')
          .then(response => response.json())
          .then(data => setAllResults(data))
          .catch(()=> setAllResults(results)); // Fallback на статичный массив
      }, []);

      // Слушатель для back/forward
      React.useEffect(() => {
        const handlePopState = (event) => {
          if (event.state && event.state.screen) {
            setCurrentScreen(event.state.screen);
          } else {
            setCurrentScreen(SCREENS.START);  // Fallback на старт
          }
        };
        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
      }, []);

      // Рендерим соответствующий экран
      if (currentScreen === SCREENS.START) {
        return (
          <StartScreen onThemeSelect={handleThemeSelect} />
        );
      }

      if (currentScreen === SCREENS.RESULTS) {
        return (
          <ResultScreen 
            currentResult={currentResult}
            allResults={allResults}
            onNewGame={handleNewGame}
            selectedTheme={selectedTheme}
          />
        );
      }

      // Не показываем игру без карточек
      if (gameImages.length === 0) {
        return <StartScreen onThemeSelect={handleThemeSelect} />;
      }

      return (
        <GameScreen 
          images={gameImages}
          selectedTheme={selectedTheme}
          onGameFinish={handleGameFinish}
          onShowResults={() => setCurrentScreen(SCREENS.RESULTS)}
          onNewGame={handleNewGame}
        />
      );
    }

    // Компонент игрового экрана
    function GameScreen({ images, selectedTheme, onGameFinish, onShowResults, onNewGame }) {
      const {
        finishedItems,
        handleReset,
        stepsCount,
        errors,
        checkItems,
        isWin,
        isGameOver
      } = useGame(images);
      // Управляем показом модального окна победы
      const [showVictoryModal, setShowVictoryModal] = React.useState(false);
      React.useEffect(() => {
        if (isWin) {
          const timerId = setTimeout(() => setShowVictoryModal(true), 100);
          return () => clearTimeout(timerId);
        }
      }, [isWin]);

      // Вычисляем производные значения
      const totalPairs = images.length / 2;
      const matchedPairs = finishedItems.length / 2;
      const remainingLives = GAME_SETTINGS.LIVES_COUNT - errors;

      return (
        <section className="game container">
          <GameHeader 
            moves={stepsCount}
            progress={(matchedPairs / totalPairs) * 100}
            remainingLives={remainingLives}
            matchedPairs={matchedPairs}
            totalPairs={totalPairs}
          />
          
          <GameBoard
            images={images}
            selectedTheme={selectedTheme}
            finishedItems={finishedItems}
            checkItems={checkItems}
            isGameOver={isGameOver}
          />

          {/* Модальное окно поражения */}
          {isGameOver && !isWin && (
            <GameModal 
              isWin={false}
              moves={stepsCount}
              matchedPairs={matchedPairs}
              onRestart={() => {
                setShowVictoryModal(false);
                handleReset();
              }}
              onNewGame={onNewGame}
              onShowResults={()=> {
                onGameFinish();
              }}
            />
          )}

          {/* Модальное окно победы */}
          {showVictoryModal && isWin && (
            <GameModal 
              isWin={true}
              moves={stepsCount}
              matchedPairs={matchedPairs}
              onRestart={() => {
                setShowVictoryModal(false);
                handleReset();
              }}
              onNewGame={onNewGame}
              onShowResults={()=> {
                onGameFinish({
                  moves: stepsCount, 
                  errors: errors
                });
              }}
            />
          )}
        </section>
      );
    }

    // Компонент шапки игры
    function GameHeader({ moves, progress, remainingLives, matchedPairs, totalPairs }) {
      return (
        <>
          <div className="progress-wrapper">
            <div className="progress" style={{ width: `${progress}%` }}></div>
          </div>
          <p className="progress-description">
            Открыто <span>{matchedPairs}</span> / <span>{totalPairs}</span>
          </p>
          <div className="steps">Шаг {moves}</div>
        </>
      );
    }

    // Компонент игрового поля 
    function GameBoard({images = [], selectedTheme = 'cats', finishedItems, checkItems, isGameOver}) {
      const [visibleItems, setVisibleItems] = React.useState([]);

      const handleCardClick = React.useCallback((id) => {
        // Игнорируем клики если игра окончена, карточка отгадана или уже видима
        if (isGameOver || finishedItems.includes(id) || visibleItems.includes(id)) {
          return;
        }

        // Логика клика по карточкам
        switch (visibleItems.length) {
          case 0:
            // Первая карточка - просто показываем
            setVisibleItems([id]);
            break;
          case 1:
            // Вторая карточка - показываем и проверяем пару
            setVisibleItems((items) => [...items, id]);
            checkItems(visibleItems[0], id);
            
            // Ставим таймер для очистки видимых карточек
            setTimeout(() => {
              setVisibleItems([]);
            }, GAME_SETTINGS.FLIP_DELAY);
            break;
          default:
            // Третья карточка и больше - просто очищаем видимые
            setVisibleItems([]);
        }
      }, [isGameOver, finishedItems, visibleItems, checkItems]);

      return (
        <ul className={`cards cards-theme-${selectedTheme}`}>
          {images.map((item) => (
            <Card
              key={item.id}
              item={item}
              isVisible={visibleItems.includes(item.id)}
              isFinished={finishedItems.includes(item.id)}
              onCardClick={handleCardClick}
            />
          ))}
        </ul>
      );
    }

    // Компонент карточки
    function Card({item, isVisible, isFinished, onCardClick}) {
      const {id, url, description} = item;
      const className = `${isVisible ? 'card-show' : ''} ${isFinished ? 'card-finished' : ''}`;

      const handleClick = () => onCardClick(id);
      
      // Обработчик клавиатуры
      const handleKeyDown = (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          onCardClick(id);
        }
      };

      return (
        <li 
          onClick={handleClick}
          onKeyDown={handleKeyDown} 
          className={`card ${className}`} 
          role="button" 
          tabIndex={isFinished ? -1 : 0} 
          aria-label={isFinished ? 'Собранная пара' : 'Закрытая карточка, нажмите Enter для открытия'}
        >
          <img src={url} alt={description || 'Изображение карточки'} />
        </li>
      );
    }

    // Компонент модального окна
    function GameModal({ isWin, moves, matchedPairs, onRestart, onNewGame, onShowResults }) {
      return (
        <div className="modal">
          <div className="modal-box">
            <h3 className="modal-caption">
              {isWin ? 'Победа!' : 'Игра окончена'}
            </h3>
            <p className="modal-description">
              {isWin 
                ? 'Теперь давайте узнаем результаты этой партии'
                : `Вы собрали ${matchedPairs} ${getDeclension(matchedPairs, ['пару', 'пары', 'пар'])}`
              }
            </p>
            <div className="modal-buttons">
              {isWin ? (
                <button 
                  className="button modal-button" 
                  type="button" 
                  onClick={onShowResults}
                >
                  Показать результаты
                </button>
              ) : (
                <>
                  <button className="button modal-button" type="button" 
                  onClick={onNewGame}>
                    Новая игра
                  </button>
                </>
              )}
            </div>
          </div>
        </div>
      );
    }

    // Компонент экрана результатов
    function ResultScreen({ currentResult, allResults, onNewGame, selectedTheme }) {
      // Фильтруем и сортируем по теме
      const combinedResults = React.useMemo(() => {
        const filteredByTheme = allResults.filter(result => result.theme === selectedTheme);
        const results = [...filteredByTheme];
        
        if (currentResult) {
          // Добавляем текущий результат (с темой)
          currentResult.theme = selectedTheme;
          results.push(currentResult);
        }
        
        // Сортируем по возрастанию шагов
        return results.sort((a, b) => a.stepsCount - b.stepsCount);
      }, [allResults, currentResult, selectedTheme]);

      return (
        <section className="result container">
          <h2>Лучшие результаты для темы "{themes[selectedTheme].name}":</h2>
          
          {currentResult && (
            <p>
              Вы завершили игру за <b>{currentResult.stepsCount} {getDeclension(currentResult.stepsCount, ['шаг', 'шага', 'шагов'])}</b>, так держать!
            </p>
          )}
          
          {combinedResults.length > 0 ? (
            <table className="result-table">
              <thead>
                <tr className="result-table-row">
                  <th>Место</th>
                  <th>Имя</th>
                  <th>Шаги</th>
                </tr>
              </thead>
              <tbody>
                {combinedResults.map((result, index) => (
                  <tr 
                    key={`${result.name}-${result.stepsCount}-${index}`}
                    className={`result-table-row ${result.isCurrent ? 'active' : ''}`}
                  >
                    <td>{index + 1}</td>
                    <td>{result.name}</td>
                    <td>{result.stepsCount}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          ) : (
            <p>Пока нет результатов для этой темы. Сыграйте, чтобы установить рекорд!</p>
          )}
          
          <p>Хотите попробовать ещё раз?</p>
          
          <div style={{ display: 'flex', justifyContent: 'center', marginTop: '24px' }}>
            <button 
              className="button result-button" 
              type="button"
              onClick={onNewGame}
            >
              Новая игра
            </button>
          </div>
        </section>
      );
    }

    // Компонент начального экрана
    function StartScreen({ onThemeSelect }) {
      return (
        <section className="rules container">
          <h2>Добро пожаловать!</h2>
          <p>Memory — игра для тренировки визуальной памяти</p>
          <div className="rules-panel">
            <h3>Правила игры</h3>
            <ul className="rules-list">
              <li>В наборе есть множество карточек – по две штуки с одним и тем же рисунком.</li>
              <li>Нужно разложить карточки «рубашкой» вверх на столе, а затем переворачивать по две.</li>
              <li>Если они совпадают – игрок забирает их и получает ещё один ход.</li>
            </ul>
          </div>
           {/* Генерируем кнопки для всех доступных тем */}
      <div className="theme-buttons">
        {Object.keys(themes).map((themeKey) => (
          <button 
            key={themeKey}
            className={`ico-button ico-button-${themeKey}`}
            type="button"
            onClick={() => onThemeSelect(themeKey)}
            aria-label={`Выбрать тему ${themes[themeKey].name}`}
          >
            {themes[themeKey].name}
          </button>
        ))}
      </div>
        </section>
      );
    }

  </script>
</body>
</html>